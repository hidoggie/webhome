<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Tracking AR - ê°€ìƒ ì•¡ì„¸ì„œë¦¬ ì²´í—˜</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ–ï¸</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #000;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #output-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            pointer-events: none;
        }
        
        #webgl-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            pointer-events: none;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            color: white;
            z-index: 10;
            max-width: 300px;
        }
        
        h1 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #4CAF50;
        }
        
        .mode-btn {
            display: block;
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .mode-btn.active {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }
        
        #status {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            font-size: 12px;
            line-height: 1.5;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 10px;
            color: white;
            text-align: center;
            max-width: 600px;
            z-index: 10;
        }
        
        .instruction-text {
            font-size: 14px;
            margin: 5px 0;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            text-align: center;
            z-index: 100;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="video" autoplay playsinline></video>
        <canvas id="output-canvas"></canvas>
        <canvas id="webgl-canvas"></canvas>
        
        <div id="controls">
            <h1>ğŸ–ï¸ Hand Tracking AR</h1>
            <button class="mode-btn active" data-mode="ring">ğŸ’ ë°˜ì§€ ì°©ìš©</button>
            <button class="mode-btn" data-mode="bracelet">ğŸ“¿ íŒ”ì°Œ ì°©ìš©</button>
            <button class="mode-btn" data-mode="ball">âš½ ê³µ ì¡ê¸°</button>
            <button class="mode-btn" data-mode="watch">âŒš ì‹œê³„ ì°©ìš©</button>
            <div id="status">
                <div>ìƒíƒœ: ì´ˆê¸°í™” ì¤‘...</div>
                <div>ì† ê°ì§€: ëŒ€ê¸° ì¤‘</div>
            </div>
        </div>
        
        <div id="instructions">
            <div class="instruction-text">âœ‹ ì¹´ë©”ë¼ ì•ì— ì†ì„ ë³´ì—¬ì£¼ì„¸ìš”</div>
            <div class="instruction-text">ğŸ’¡ ìœ„ ë²„íŠ¼ì„ ëˆŒëŸ¬ ë‹¤ë¥¸ ì•¡ì„¸ì„œë¦¬ë¥¼ ì²´í—˜í•˜ì„¸ìš”</div>
        </div>
        
        <div class="loading" id="loading">
            <div class="spinner"></div>
            <div>ëª¨ë¸ ë¡œë”© ì¤‘...</div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // ì „ì—­ ë³€ìˆ˜
        let camera, scene, renderer;
        let handObjects = { left: null, right: null };
        let currentMode = 'ring';
        let videoElement, outputCanvas, webglCanvas, canvasCtx;
        let hands;
        
        // ì† ëœë“œë§ˆí¬ ì¸ë±ìŠ¤
        const LANDMARKS = {
            WRIST: 0,
            THUMB_TIP: 4,
            INDEX_TIP: 8,
            MIDDLE_TIP: 12,
            RING_TIP: 16,
            PINKY_TIP: 20,
            INDEX_MCP: 5,
            MIDDLE_MCP: 9,
            RING_MCP: 13,
            PINKY_MCP: 17
        };
        
        // ì´ˆê¸°í™”
        function init() {
            videoElement = document.getElementById('video');
            outputCanvas = document.getElementById('output-canvas');
            webglCanvas = document.getElementById('webgl-canvas');
            canvasCtx = outputCanvas.getContext('2d');
            
            setupThreeJS();
            setupMediaPipe();
            setupEventListeners();
        }
        
        // Three.js ì„¤ì •
        function setupThreeJS() {
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            camera.position.z = 5;
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: webglCanvas, 
                alpha: true,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            
            // ì¡°ëª… ì„¤ì •
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);
            
            createAccessories();
            
            window.addEventListener('resize', onWindowResize);
        }
        
        // ì•¡ì„¸ì„œë¦¬ ìƒì„±
        function createAccessories() {
            // ë°˜ì§€
            const ringGeometry = new THREE.TorusGeometry(0.05, 0.015, 16, 32);
            const ringMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFD700,
                metalness: 0.9,
                roughness: 0.1,
                emissive: 0xFFD700,
                emissiveIntensity: 0.2
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            
            // íŒ”ì°Œ
            const braceletGeometry = new THREE.TorusGeometry(0.12, 0.02, 16, 32);
            const braceletMaterial = new THREE.MeshStandardMaterial({
                color: 0xC0C0C0,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0xC0C0C0,
                emissiveIntensity: 0.1
            });
            const bracelet = new THREE.Mesh(braceletGeometry, braceletMaterial);
            
            // ê³µ
            const ballGeometry = new THREE.SphereGeometry(0.15, 32, 32);
            const ballMaterial = new THREE.MeshStandardMaterial({
                color: 0xFF4444,
                metalness: 0.3,
                roughness: 0.7,
                emissive: 0xFF0000,
                emissiveIntensity: 0.1
            });
            const ball = new THREE.Mesh(ballGeometry, ballMaterial);
            
            // ì‹œê³„
            const watchGroup = new THREE.Group();
            const watchBandGeometry = new THREE.CylinderGeometry(0.09, 0.09, 0.15, 32);
            const watchBandMaterial = new THREE.MeshStandardMaterial({
                color: 0x222222,
                metalness: 0.2,
                roughness: 0.8
            });
            const watchBand = new THREE.Mesh(watchBandGeometry, watchBandMaterial);
            
            const watchFaceGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.05, 32);
            const watchFaceMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                metalness: 0.8,
                roughness: 0.2
            });
            const watchFace = new THREE.Mesh(watchFaceGeometry, watchFaceMaterial);
            watchFace.position.y = 0.05;
            
            const screenGeometry = new THREE.CircleGeometry(0.08, 32);
            const screenMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                emissive: 0x0088ff,
                emissiveIntensity: 0.3
            });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.set(0, 0.08, 0.051);
            
            watchGroup.add(watchBand);
            watchGroup.add(watchFace);
            watchGroup.add(screen);
            watchGroup.rotation.z = Math.PI / 2;
            
            // ê° ì†ì— ì•¡ì„¸ì„œë¦¬ í• ë‹¹
            handObjects.left = {
                ring: ring.clone(),
                bracelet: bracelet.clone(),
                ball: ball.clone(),
                watch: watchGroup.clone()
            };
            
            handObjects.right = {
                ring: ring.clone(),
                bracelet: bracelet.clone(),
                ball: ball.clone(),
                watch: watchGroup.clone()
            };
            
            // ì”¬ì— ì¶”ê°€
            Object.values(handObjects.left).forEach(obj => scene.add(obj));
            Object.values(handObjects.right).forEach(obj => scene.add(obj));
            
            updateAccessoryVisibility();
        }
        
        // ì•¡ì„¸ì„œë¦¬ ê°€ì‹œì„± ì—…ë°ì´íŠ¸
        function updateAccessoryVisibility() {
            ['left', 'right'].forEach(hand => {
                Object.keys(handObjects[hand]).forEach(mode => {
                    handObjects[hand][mode].visible = (mode === currentMode);
                });
            });
        }
        
        // MediaPipe ì„¤ì •
        function setupMediaPipe() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });
            
            hands.onResults(onResults);
            
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({ image: videoElement });
                },
                width: 1280,
                height: 720
            });
            camera.start();
            
            document.getElementById('loading').style.display = 'none';
            updateStatus('ì¤€ë¹„ ì™„ë£Œ', 'green');
        }
        
        // ì† ì¶”ì  ê²°ê³¼ ì²˜ë¦¬
        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                updateStatus(`ì† ê°ì§€ë¨ (${results.multiHandLandmarks.length}ê°œ)`, 'green');
                
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const landmarks = results.multiHandLandmarks[i];
                    const handedness = results.multiHandedness[i].label.toLowerCase();
                    
                    // ì† ê·¸ë¦¬ê¸° (ì„ íƒì )
                    // drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                    // drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 3});
                    
                    updateHandObject(landmarks, handedness);
                }
            } else {
                updateStatus('ì†ì„ ë³´ì—¬ì£¼ì„¸ìš”', 'orange');
            }
            
            canvasCtx.restore();
            
            renderer.render(scene, camera);
        }
        
        // ì† ê°ì²´ ì—…ë°ì´íŠ¸
        function updateHandObject(landmarks, handedness) {
            const handObj = handObjects[handedness][currentMode];
            
            if (!handObj) return;
            
            switch (currentMode) {
                case 'ring':
                    // ì•½ì§€ì— ë°˜ì§€ ìœ„ì¹˜
                    const ringBase = landmarks[LANDMARKS.RING_MCP];
                    const ringTip = landmarks[LANDMARKS.RING_TIP];
                    
                    const ringPos = {
                        x: (ringBase.x + ringTip.x) / 2,
                        y: (ringBase.y + ringTip.y) / 2,
                        z: (ringBase.z + ringTip.z) / 2
                    };
                    
                    updateObjectPosition(handObj, ringPos, handedness);
                    
                    // ë°˜ì§€ íšŒì „
                    const ringDir = new THREE.Vector3(
                        ringTip.x - ringBase.x,
                        ringTip.y - ringBase.y,
                        ringTip.z - ringBase.z
                    ).normalize();
                    handObj.quaternion.setFromUnitVectors(
                        new THREE.Vector3(0, 1, 0),
                        ringDir
                    );
                    break;
                    
                case 'bracelet':
                    // ì†ëª©ì— íŒ”ì°Œ ìœ„ì¹˜
                    const wrist = landmarks[LANDMARKS.WRIST];
                    updateObjectPosition(handObj, wrist, handedness);
                    
                    // íŒ”ì°Œ íšŒì „
                    const indexMCP = landmarks[LANDMARKS.INDEX_MCP];
                    const braceletDir = new THREE.Vector3(
                        indexMCP.x - wrist.x,
                        indexMCP.y - wrist.y,
                        indexMCP.z - wrist.z
                    ).normalize();
                    handObj.quaternion.setFromUnitVectors(
                        new THREE.Vector3(0, 0, 1),
                        braceletDir
                    );
                    break;
                    
                case 'ball':
                    // ì†ë°”ë‹¥ ì¤‘ì•™ì— ê³µ ìœ„ì¹˜ (ì¡ëŠ” ëª¨ì…˜)
                    const indexTip = landmarks[LANDMARKS.INDEX_TIP];
                    const thumbTip = landmarks[LANDMARKS.THUMB_TIP];
                    
                    const palmCenter = {
                        x: (indexTip.x + thumbTip.x) / 2,
                        y: (indexTip.y + thumbTip.y) / 2,
                        z: (indexTip.z + thumbTip.z) / 2
                    };
                    
                    updateObjectPosition(handObj, palmCenter, handedness);
                    
                    // í•€ì¹˜ ê±°ë¦¬ ê³„ì‚°
                    const pinchDist = Math.sqrt(
                        Math.pow(indexTip.x - thumbTip.x, 2) +
                        Math.pow(indexTip.y - thumbTip.y, 2) +
                        Math.pow(indexTip.z - thumbTip.z, 2)
                    );
                    
                    // ê³µ í¬ê¸° ì¡°ì ˆ (ì¡ì„ ë•Œ ì‘ì•„ì§)
                    const scale = Math.max(0.5, Math.min(1.5, pinchDist * 5));
                    handObj.scale.set(scale, scale, scale);
                    break;
                    
                case 'watch':
                    // ì†ëª©ì— ì‹œê³„ ìœ„ì¹˜
                    const watchWrist = landmarks[LANDMARKS.WRIST];
                    const watchIndexMCP = landmarks[LANDMARKS.INDEX_MCP];
                    
                    updateObjectPosition(handObj, watchWrist, handedness);
                    
                    // ì‹œê³„ íšŒì „
                    const watchDir = new THREE.Vector3(
                        watchIndexMCP.x - watchWrist.x,
                        watchIndexMCP.y - watchWrist.y,
                        watchIndexMCP.z - watchWrist.z
                    ).normalize();
                    
                    handObj.quaternion.setFromUnitVectors(
                        new THREE.Vector3(0, 1, 0),
                        watchDir
                    );
                    break;
            }
        }
        
        // ê°ì²´ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (í™”ë©´ ì¢Œí‘œë¥¼ 3D ì¢Œí‘œë¡œ ë³€í™˜)
        function updateObjectPosition(obj, landmark, handedness) {
            // MediaPipe ì¢Œí‘œëŠ” 0~1 ë²”ìœ„, í™”ë©´ì˜ ì¤‘ì‹¬ì„ 0ìœ¼ë¡œ ë³€í™˜
            const x = (landmark.x - 0.5) * 10;
            const y = -(landmark.y - 0.5) * 10;
            const z = -landmark.z * 10;
            
            // ì™¼ì†/ì˜¤ë¥¸ì†ì— ë”°ë¼ x ì¢Œí‘œ ì¡°ì •
            obj.position.set(handedness === 'left' ? -x : x, y, z);
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        function setupEventListeners() {
            const buttons = document.querySelectorAll('.mode-btn');
            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    buttons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentMode = btn.dataset.mode;
                    updateAccessoryVisibility();
                });
            });
        }
        
        // ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateStatus(message, color) {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = `
                <div style="color: ${color}">ìƒíƒœ: ${message}</div>
                <div>ëª¨ë“œ: ${getModeText(currentMode)}</div>
            `;
        }
        
        function getModeText(mode) {
            const texts = {
                'ring': 'ğŸ’ ë°˜ì§€',
                'bracelet': 'ğŸ“¿ íŒ”ì°Œ',
                'ball': 'âš½ ê³µ',
                'watch': 'âŒš ì‹œê³„'
            };
            return texts[mode] || mode;
        }
        
        // ì°½ í¬ê¸° ì¡°ì •
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            outputCanvas.width = window.innerWidth;
            outputCanvas.height = window.innerHeight;
            webglCanvas.width = window.innerWidth;
            webglCanvas.height = window.innerHeight;
        }
        
        // ì‹œì‘
        init();
    </script>
</body>
</html>
